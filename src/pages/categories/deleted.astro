---
import Layout from "@layouts/Layout.astro";
import Header from "@comps/layout/Header.astro";
import ConfirmationModal from "@comps/ConfirmationModal.astro";
import { actions } from "astro:actions";
import { formatDateForDisplay } from "@lib/date-utils.ts";
import Bin from "@comps/svgs/mono/Bin.astro";
import Folder from "@comps/svgs/mono/Folder.astro";
import DeletedInfo from "@comps/DeletedInfo.astro";

const user = Astro.locals.user;

if (!user) {
    return Astro.redirect("/login");
}

// Check if user is in a family first
const userResult = await Astro.callAction(actions.getFamilyDetails, {});
const userInFamily = userResult.data?.ok && userResult.data.family;

if (!userInFamily) {
    return Astro.redirect("/categories");
}

// Get deleted categories
const categoriesResult = await Astro.callAction(actions.getCategories, {
    includeDeleted: true,
});
const rawCategories = categoriesResult.data?.ok
    ? categoriesResult.data.categories
    : [];

// Normalize categories into a flat array
let normalizedCategories: any[] = [];
if (Array.isArray(rawCategories)) {
    normalizedCategories = rawCategories;
} else if (rawCategories && typeof rawCategories === "object") {
    const vals = Object.values(rawCategories) as any[];
    normalizedCategories = vals.flatMap((v) => (Array.isArray(v) ? v : [v]));
} else {
    normalizedCategories = [];
}

const deletedCategories = normalizedCategories
    ? normalizedCategories.filter(
          (category: any) => category.deletedAt !== null,
      )
    : [];

const deletedMsgs: string[] = [
    "Deleted categories are hidden from the main interface but their data is preserved",
    "All associated transactions remain intact",
    "You can restore deleted categories at any time",
    "Restored categories will reappear in your category lists",
];
---

<Layout title="Deleted Categories" description="Manage deleted categories">
    <main class="bg-gray-900 p-8 text-white">
        <Header currentPage="categories" user={user} />
        <!-- Deleted Categories List -->
        <div
            class="bg-gray-800 shadow-lg px-6 py-6 rounded-lg mx-auto max-w-7xl"
        >
            <div class="flex items-center justify-between mb-6">
                <div class="flex items-baseline-last gap-x-4">
                    <h1
                        class="font-semibold text-purple-400 text-xl flex items-center gap-x-2"
                    >
                        <Bin />
                        Deleted Categories
                    </h1>
                    <a
                        href="/categories"
                        class="text-purple-400 hover:text-purple-300 flex items-center gap-x-2"
                    >
                        <Folder class="w-4 h-4" />
                        <span>Categories</span>
                    </a>
                </div>
                <div id="bulkHeaderBar" class="hidden items-center gap-x-4">
                    <div class="text-sm text-gray-300">
                        <span id="selectedCount">0</span> selected (max 10)
                    </div>
                    <div class="flex items-center gap-x-2">
                        <button
                            id="bulkRestoreBtn"
                            class="bg-green-600 hover:bg-green-700 text-white px-3 py-1 rounded text-sm disabled:opacity-40 disabled:cursor-not-allowed"
                            disabled>Restore Selected</button
                        >
                        <button
                            id="bulkPurgeBtn"
                            class="bg-red-600 hover:bg-red-700 text-white px-3 py-1 rounded text-sm disabled:opacity-40 disabled:cursor-not-allowed"
                            disabled>Purge Selected</button
                        >
                        <button
                            id="clearSelectionBtn"
                            class="bg-gray-600 hover:bg-gray-500 text-white px-3 py-1 rounded text-sm"
                            >Clear</button
                        >
                        <button
                            id="selectAllBtn"
                            class="bg-purple-600 hover:bg-purple-500 text-white px-3 py-1 rounded text-sm disabled:opacity-40 disabled:cursor-not-allowed"
                            disabled>Select All</button
                        >
                    </div>
                </div>
            </div>

            {
                deletedCategories.length === 0 ? (
                    <div class="text-center py-10 text-gray-400">
                        <div class="mb-4 flex justify-center">
                            <Bin class="w-14 h-14" />
                        </div>
                        <p class="text-xl font-semibold text-gray-300 mb-2">
                            No deleted categories
                        </p>
                        <p>All your categories are active!</p>
                    </div>
                ) : (
                    <div
                        class="flex flex-col gap-y-4"
                        id="deletedCategoriesList"
                    >
                        {deletedCategories.map((category: any) => (
                            <div
                                class="bg-gray-700 rounded-lg p-4 border-l-4 border-red-500 category-item"
                                data-category-id={category.id}
                                data-category-name={category.name}
                            >
                                <div class="flex items-center justify-between">
                                    <div class="flex items-center gap-x-4">
                                        <div class="w-4 h-4 rounded-sm opacity-50 selection-checkbox-wrapper relative">
                                            <input
                                                type="checkbox"
                                                class="hidden selection-checkbox"
                                                value={category.id}
                                                data-name={category.name}
                                            />
                                            <div
                                                class="w-4 h-4 rounded-full color-indicator"
                                                style={`background-color: ${category.color}`}
                                            />
                                        </div>
                                        <div>
                                            <h3 class="font-semibold text-white">
                                                {category.name}
                                                <span class="text-red-400 text-sm ml-2">
                                                    (Deleted)
                                                </span>
                                            </h3>
                                            {category.parentId && (
                                                <p class="text-sm text-gray-400">
                                                    Subcategory
                                                </p>
                                            )}
                                            <p class="text-xs text-gray-500 mt-1">
                                                Deleted on:
                                                {formatDateForDisplay(
                                                    category.deletedAt,
                                                    {
                                                        includeTime: true,
                                                        dateStyle: "long",
                                                    },
                                                )}
                                            </p>
                                        </div>
                                    </div>

                                    <div class="flex items-center gap-x-2 per-item-actions">
                                        <form class="restore-category-form inline">
                                            <input
                                                type="hidden"
                                                name="id"
                                                value={category.id}
                                            />
                                            <button
                                                type="submit"
                                                data-category-name={
                                                    category.name
                                                }
                                                class="bg-green-600 hover:bg-green-700 text-white px-3 py-1 rounded text-sm transition-colors"
                                            >
                                                Restore
                                            </button>
                                        </form>
                                        <form class="purge-category-form inline">
                                            <input
                                                type="hidden"
                                                name="id"
                                                value={category.id}
                                            />
                                            <button
                                                type="submit"
                                                data-category-name={
                                                    category.name
                                                }
                                                class="bg-red-600 hover:bg-red-700 text-white px-3 py-1 rounded text-sm transition-colors"
                                            >
                                                Purge
                                            </button>
                                        </form>
                                    </div>
                                </div>
                            </div>
                        ))}
                    </div>
                )
            }
        </div>
        <DeletedInfo
            classes="mx-auto max-w-7xl"
            title="About Deleted Categories"
            listItems={deletedMsgs}
        />
    </main>

    <ConfirmationModal variant="info" />

    <script>
        // Multi-select state
        const selection = new Set<number>();
        let selectionMode = false; // becomes true after first shift-click
        const MAX_BULK = 10;

        function updateBulkBar() {
            const bulkHeaderBar = document.getElementById("bulkHeaderBar");
            if (!bulkHeaderBar) return;
            const countEl = document.getElementById("selectedCount");
            if (countEl) countEl.textContent = String(selection.size);
            if (selection.size > 0) {
                bulkHeaderBar.classList.remove("hidden");
                bulkHeaderBar.classList.add("flex");
            } else {
                bulkHeaderBar.classList.add("hidden");
                bulkHeaderBar.classList.remove("flex");
                // When nothing selected, return to default mode
                exitSelectionMode();
            }
            (
                document.getElementById("bulkRestoreBtn") as HTMLButtonElement
            )?.toggleAttribute("disabled", selection.size === 0);
            (
                document.getElementById("bulkPurgeBtn") as HTMLButtonElement
            )?.toggleAttribute("disabled", selection.size === 0);
            const selectAllBtn = document.getElementById(
                "selectAllBtn",
            ) as HTMLButtonElement | null;
            if (selectAllBtn) {
                const total =
                    document.querySelectorAll(".category-item").length;
                const disableSelectAll =
                    selection.size === 0 ||
                    selection.size >= Math.min(total, MAX_BULK);
                selectAllBtn.toggleAttribute("disabled", disableSelectAll);
            }
        }

        function enterSelectionMode() {
            if (selectionMode) return;
            selectionMode = true;
            document.querySelectorAll(".selection-checkbox").forEach((el) => {
                (el as HTMLInputElement).classList.remove("hidden");
            });
            document.querySelectorAll(".color-indicator").forEach((el) => {
                el.classList.add("hidden");
            });
            document.querySelectorAll(".per-item-actions").forEach((el) => {
                (el as HTMLElement).classList.add("hidden");
            });
            document
                .getElementById("deletedCategoriesList")
                ?.classList.add("select-none");
        }

        function clearSelection() {
            selection.clear();
            document.querySelectorAll(".selection-checkbox").forEach((el) => {
                (el as HTMLInputElement).checked = false;
            });
            // Clear any text selection in the browser
            try {
                window.getSelection()?.removeAllRanges();
            } catch {}
            updateBulkBar();
        }

        function exitSelectionMode() {
            if (!selectionMode) return;
            selectionMode = false;
            // Hide checkboxes, show color indicators and per-item actions again
            document.querySelectorAll(".selection-checkbox").forEach((el) => {
                el.classList.add("hidden");
            });
            document.querySelectorAll(".color-indicator").forEach((el) => {
                el.classList.remove("hidden");
            });
            document.querySelectorAll(".per-item-actions").forEach((el) => {
                (el as HTMLElement).classList.remove("hidden");
            });
            document
                .getElementById("deletedCategoriesList")
                ?.classList.remove("select-none");
            // Also clear any lingering text selection
            try {
                window.getSelection()?.removeAllRanges();
            } catch {}
        }

        // ESC key support to unselect all & exit mode
        window.addEventListener("keydown", (e) => {
            if (e.key === "Escape" && selectionMode) {
                clearSelection();
                exitSelectionMode();
            }
        });

        document.addEventListener("click", (e) => {
            const target = e.target as HTMLElement;
            if (target.closest(".category-item")) {
                const container = target.closest(
                    ".category-item",
                ) as HTMLElement;
                const id = parseInt(
                    container.getAttribute("data-category-id") || "0",
                );
                const checkbox = container.querySelector(
                    ".selection-checkbox",
                ) as HTMLInputElement | null;
                if (e.shiftKey && id && checkbox) {
                    // Prevent browser text selection when shift-clicking
                    e.preventDefault();
                    enterSelectionMode();
                    if (selection.has(id)) {
                        selection.delete(id);
                        checkbox.checked = false;
                    } else {
                        if (selection.size < MAX_BULK) {
                            selection.add(id);
                            checkbox.checked = true;
                        }
                    }
                    updateBulkBar();
                }
            }
        });

        // Direct checkbox click (without needing shift)
        document.addEventListener("change", (e) => {
            const target = e.target as HTMLElement;
            if (target.classList.contains("selection-checkbox")) {
                const cb = target as HTMLInputElement;
                const id = parseInt(cb.value || "0");
                if (!id) return;
                if (!selectionMode) {
                    enterSelectionMode();
                }
                if (cb.checked) {
                    if (selection.size >= MAX_BULK && !selection.has(id)) {
                        // Revert if over limit
                        cb.checked = false;
                        return;
                    }
                    selection.add(id);
                } else {
                    selection.delete(id);
                }
                updateBulkBar();
            }
        });

        document
            .getElementById("clearSelectionBtn")
            ?.addEventListener("click", () => {
                clearSelection();
            });

        document
            .getElementById("selectAllBtn")
            ?.addEventListener("click", () => {
                // Select all items up to MAX_BULK
                const items = Array.from(
                    document.querySelectorAll(".category-item"),
                ) as HTMLElement[];
                let changed = false;
                for (const el of items) {
                    if (selection.size >= MAX_BULK) break;
                    const id = parseInt(
                        el.getAttribute("data-category-id") || "0",
                    );
                    if (id && !selection.has(id)) {
                        selection.add(id);
                        const cb = el.querySelector(
                            ".selection-checkbox",
                        ) as HTMLInputElement | null;
                        if (cb) cb.checked = true;
                        changed = true;
                    }
                }
                if (changed) updateBulkBar();
            });

        document
            .getElementById("bulkRestoreBtn")
            ?.addEventListener("click", async () => {
                if (selection.size === 0) return;
                const names: string[] = [];
                selection.forEach((id) => {
                    const el = document.querySelector(
                        `.category-item[data-category-id="${id}"]`,
                    );
                    if (el) {
                        const n = el.getAttribute("data-category-name");
                        if (n) names.push(n);
                    }
                });
                const confirmationModal = document.getElementById(
                    "confirmationModal",
                ) as any;
                confirmationModal?.show({
                    title: "Restore Categories",
                    message: `Restore these categories?\n\n${names.join("\n")}`,
                    confirmLabel: "Restore",
                    cancelLabel: "Cancel",
                    onConfirm: async () => {
                        const csrfInput = document.querySelector(
                            'input[name="_csrf_token"]',
                        ) as HTMLInputElement;
                        const formData = new FormData();
                        formData.set("ids", Array.from(selection).join(","));
                        if (csrfInput?.value)
                            formData.set("_csrf_token", csrfInput.value);
                        const { ToastService } = await import("@lib/toast.ts");
                        try {
                            const { actions } = await import("astro:actions");
                            const result =
                                await actions.bulkRestoreCategories(formData);
                            if (result.data?.ok) {
                                ToastService.success(
                                    `Restored ${result.data.restored} categories.`,
                                );
                                if (result.data.skipped?.length) {
                                    ToastService.info(
                                        `${result.data.skipped.length} skipped.`,
                                    );
                                }
                                window.location.reload();
                            } else {
                                ToastService.error(
                                    result.data?.error || "Bulk restore failed",
                                );
                            }
                        } catch (err) {
                            console.error(err);
                        }
                    },
                });
            });

        document
            .getElementById("bulkPurgeBtn")
            ?.addEventListener("click", async () => {
                if (selection.size === 0) return;
                const names: string[] = [];
                selection.forEach((id) => {
                    const el = document.querySelector(
                        `.category-item[data-category-id="${id}"]`,
                    );
                    if (el) {
                        const n = el.getAttribute("data-category-name");
                        if (n) names.push(n);
                    }
                });
                const confirmationModal = document.getElementById(
                    "confirmationModal",
                ) as any;
                confirmationModal?.show({
                    title: "Permanently Delete Categories",
                    message: `Permanently delete these categories? This cannot be undone.\n\n${names.join("\n")}`,
                    confirmLabel: "Purge",
                    cancelLabel: "Cancel",
                    onConfirm: async () => {
                        const csrfInput = document.querySelector(
                            'input[name="_csrf_token"]',
                        ) as HTMLInputElement;
                        const formData = new FormData();
                        formData.set("ids", Array.from(selection).join(","));
                        if (csrfInput?.value)
                            formData.set("_csrf_token", csrfInput.value);
                        const { ToastService } = await import("@lib/toast.ts");
                        try {
                            const { actions } = await import("astro:actions");
                            const result =
                                await actions.bulkPurgeCategories(formData);
                            if (result.data?.ok) {
                                ToastService.success(
                                    `Purged ${result.data.purged} categories.`,
                                );
                                if (result.data.skipped?.length) {
                                    ToastService.info(
                                        `${result.data.skipped.length} skipped.`,
                                    );
                                }
                                window.location.reload();
                            } else {
                                ToastService.error(
                                    result.data?.error || "Bulk purge failed",
                                );
                            }
                        } catch (err) {
                            console.error(err);
                        }
                    },
                });
            });

        // Handle restore category forms
        document.addEventListener("DOMContentLoaded", function () {
            const restoreForms = document.querySelectorAll(
                ".restore-category-form",
            );

            restoreForms.forEach((form) => {
                form.addEventListener("submit", async function (e) {
                    e.preventDefault();

                    const button = form.querySelector("button");
                    const categoryName =
                        button?.getAttribute("data-category-name");

                    // Show confirmation modal
                    const confirmationModal = document.getElementById(
                        "confirmationModal",
                    ) as any;
                    if (!confirmationModal) {
                        console.error("Confirmation modal not found");
                        return;
                    }

                    confirmationModal.show({
                        title: "Restore Category",
                        message: `Are you sure you want to restore "${categoryName}"?`,
                        confirmLabel: "Restore",
                        cancelLabel: "Cancel",
                        onConfirm: async () => {
                            const csrfInput = document.querySelector(
                                'input[name="_csrf_token"]',
                            ) as HTMLInputElement;

                            const formData = new FormData(
                                form as HTMLFormElement,
                            );

                            if (csrfInput && csrfInput.value) {
                                formData.set("_csrf_token", csrfInput.value);
                            }

                            const { ToastService } = await import(
                                "@lib/toast.ts"
                            );

                            try {
                                const { actions } = await import(
                                    "astro:actions"
                                );
                                const result =
                                    await actions.restoreCategory(formData);

                                if (result.data?.ok) {
                                    ToastService.success(
                                        "Category restored successfully!",
                                    );
                                    // Reload the page to show updated data
                                    window.location.reload();
                                } else {
                                    ToastService.error(
                                        result.data?.error ||
                                            "Failed to restore category",
                                    );
                                    console.error(
                                        "Category restore failed:",
                                        result.error || result.data?.error,
                                    );
                                }
                            } catch (error) {
                                ToastService.error(
                                    "An error occurred. Please try again.",
                                );
                                console.error(
                                    "Error restoring category:",
                                    error,
                                );
                            }
                        },
                    });
                });
            });

            // Handle purge category forms
            const purgeForms = document.querySelectorAll(
                ".purge-category-form",
            );

            purgeForms.forEach((form) => {
                form.addEventListener("submit", async function (e) {
                    e.preventDefault();

                    const button = form.querySelector("button");
                    const categoryName =
                        button?.getAttribute("data-category-name");

                    // Show confirmation modal
                    const confirmationModal = document.getElementById(
                        "confirmationModal",
                    ) as any;
                    if (!confirmationModal) {
                        console.error("Confirmation modal not found");
                        return;
                    }

                    confirmationModal.show({
                        title: "Permanently Delete Category",
                        message: `Are you sure you want to permanently delete "${categoryName}"? This action cannot be undone and will remove this category from all transactions and subcategories.`,
                        confirmLabel: "Purge",
                        cancelLabel: "Cancel",
                        onConfirm: async () => {
                            const csrfInput = document.querySelector(
                                'input[name="_csrf_token"]',
                            ) as HTMLInputElement;

                            const formData = new FormData(
                                form as HTMLFormElement,
                            );

                            if (csrfInput && csrfInput.value) {
                                // Ensure the CSRF field is included/overwritten
                                formData.set("_csrf_token", csrfInput.value);
                            }

                            const { ToastService } = await import(
                                "@lib/toast.ts"
                            );

                            try {
                                const { actions } = await import(
                                    "astro:actions"
                                );
                                const result =
                                    await actions.purgeCategory(formData);

                                if (result.data?.ok) {
                                    ToastService.success(
                                        "Category permanently deleted!",
                                    );
                                    // Reload the page to show updated data
                                    window.location.reload();
                                } else {
                                    ToastService.error(
                                        result.data?.error ||
                                            "Failed to permanently delete category",
                                    );
                                    console.error(
                                        "Category purge failed:",
                                        result.error || result.data?.error,
                                    );
                                }
                            } catch (error) {
                                ToastService.error(
                                    "An error occurred. Please try again.",
                                );
                                console.error("Error purging category:", error);
                            }
                        },
                    });
                });
            });
        });
    </script>
</Layout>
