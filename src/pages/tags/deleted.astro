---
import Layout from "@layouts/Layout.astro";
import Header from "@comps/layout/Header.astro";
import ConfirmationModal from "@comps/ConfirmationModal.astro";
import { actions } from "astro:actions";
import { formatDateForDisplay } from "@lib/date-utils.ts";
import Bin from "@comps/svgs/mono/Bin.astro";
import Tag from "@comps/svgs/mono/Tag.astro";
import DeletedInfo from "@/components/DeletedInfo.astro";

const user = Astro.locals.user;

if (!user) {
    return Astro.redirect("/login");
}

// Check if user is in a family first
const userResult = await Astro.callAction(actions.getFamilyDetails, {});
const userInFamily = userResult.data?.ok && userResult.data.family;

if (!userInFamily) {
    return Astro.redirect("/tags");
}

// Get deleted tags
const tagsResult = await Astro.callAction(actions.getTags, {
    includeDeleted: true,
});
const allTags = tagsResult.data?.ok ? tagsResult.data.tags : [];
const deletedTags = allTags
    ? allTags.filter((tag: any) => tag.deletedAt !== null)
    : [];

const deletedInfoItems = [
    "Deleted tags are hidden from the main interface but their data is preserved",
    "All associated transactions remain intact",
    "You can restore deleted tags at any time",
    "Restored tags will reappear in your tag lists",
];
---

<Layout title="Deleted Tags" description="Manage deleted tags">
    <main class="bg-gray-900 p-8 text-white">
        <Header currentPage="tags" user={user} />
        <!-- Deleted Tags List -->
        <div
            class="bg-gray-800 shadow-lg px-6 py-6 rounded-lg mx-auto max-w-7xl"
        >
            <div class="flex items-center justify-between mb-6">
                <div class="flex items-baseline-last gap-x-4">
                    <h1
                        class="font-semibold text-purple-400 text-xl flex items-center gap-x-2"
                    >
                        <Bin />
                        Deleted Tags
                    </h1>
                    <a
                        href="/tags"
                        class="text-purple-400 hover:text-purple-300 flex items-center gap-x-2"
                    >
                        <Tag class="w-4 h-4" />
                        <span>Tags</span>
                    </a>
                </div>
                <div id="bulkHeaderBar" class="hidden items-center gap-x-4">
                    <div class="text-sm text-gray-300">
                        <span id="selectedCount">0</span> selected (max 10)
                    </div>
                    <div class="flex items-center gap-x-2">
                        <button
                            id="bulkRestoreBtn"
                            class="bg-green-600 hover:bg-green-700 text-white px-3 py-1 rounded text-sm disabled:opacity-40 disabled:cursor-not-allowed"
                            disabled>Restore Selected</button
                        >
                        <button
                            id="bulkPurgeBtn"
                            class="bg-red-600 hover:bg-red-700 text-white px-3 py-1 rounded text-sm disabled:opacity-40 disabled:cursor-not-allowed"
                            disabled>Purge Selected</button
                        >
                        <button
                            id="clearSelectionBtn"
                            class="bg-gray-600 hover:bg-gray-500 text-white px-3 py-1 rounded text-sm"
                            >Clear</button
                        >
                        <button
                            id="selectAllBtn"
                            class="bg-purple-600 hover:bg-purple-500 text-white px-3 py-1 rounded text-sm disabled:opacity-40 disabled:cursor-not-allowed"
                            disabled>Select All</button
                        >
                    </div>
                </div>
            </div>

            {
                deletedTags.length === 0 ? (
                    <div class="text-center py-10 text-gray-400">
                        <div class="mb-4 flex justify-center">
                            <Bin class="w-14 h-14" />
                        </div>
                        <p class="text-xl font-semibold text-gray-300 mb-2">
                            No deleted tags
                        </p>
                        <p>All your tags are active!</p>
                    </div>
                ) : (
                    <div class="flex flex-col gap-y-4" id="deletedTagsList">
                        {deletedTags.map((tag: any) => (
                            <div
                                class="bg-gray-700 rounded-lg p-4 border-l-4 border-red-500 tag-item"
                                data-tag-id={tag.id}
                                data-tag-name={tag.name}
                            >
                                <div class="flex items-center justify-between">
                                    <div class="flex items-center gap-x-4">
                                        <div class="w-4 h-4 rounded-sm opacity-50 selection-checkbox-wrapper relative">
                                            <input
                                                type="checkbox"
                                                class="hidden selection-checkbox"
                                                value={tag.id}
                                                data-name={tag.name}
                                            />
                                            <div
                                                class="w-4 h-4 rounded-full color-indicator"
                                                style={`background-color: ${tag.color}`}
                                            />
                                        </div>
                                        <div>
                                            <h3 class="font-semibold text-white">
                                                {tag.name}
                                                <span class="text-red-400 text-sm ml-2">
                                                    (Deleted)
                                                </span>
                                            </h3>
                                            <p class="text-xs text-gray-500 mt-1">
                                                Deleted on:
                                                {formatDateForDisplay(
                                                    tag.deletedAt,
                                                    {
                                                        includeTime: true,
                                                        dateStyle: "long",
                                                    },
                                                )}
                                            </p>
                                        </div>
                                    </div>
                                    <div class="flex items-center gap-x-2 per-item-actions">
                                        <form class="restore-tag-form inline">
                                            <input
                                                type="hidden"
                                                name="id"
                                                value={tag.id}
                                            />
                                            <button
                                                type="submit"
                                                data-tag-name={tag.name}
                                                class="bg-green-600 hover:bg-green-700 text-white px-3 py-1 rounded text-sm transition-colors"
                                            >
                                                Restore
                                            </button>
                                        </form>
                                        <form class="purge-tag-form inline">
                                            <input
                                                type="hidden"
                                                name="id"
                                                value={tag.id}
                                            />
                                            <button
                                                type="submit"
                                                data-tag-name={tag.name}
                                                class="bg-red-600 hover:bg-red-700 text-white px-3 py-1 rounded text-sm transition-colors"
                                            >
                                                Purge
                                            </button>
                                        </form>
                                    </div>
                                </div>
                            </div>
                        ))}
                    </div>
                )
            }
        </div>
        <DeletedInfo
            classes="mx-auto max-w-7xl"
            title="Deleted Tags Information"
            listItems={deletedInfoItems}
        />
    </main>

    <ConfirmationModal variant="info" />

    <script>
        // Multi-select state for tags
        const selection = new Set<number>();
        let selectionMode = false;
        const MAX_BULK = 10;

        function updateBulkBar() {
            const bulkHeaderBar = document.getElementById("bulkHeaderBar");
            if (!bulkHeaderBar) return;
            const countEl = document.getElementById("selectedCount");
            if (countEl) countEl.textContent = String(selection.size);
            if (selection.size > 0) {
                bulkHeaderBar.classList.remove("hidden");
                bulkHeaderBar.classList.add("flex");
            } else {
                bulkHeaderBar.classList.add("hidden");
                bulkHeaderBar.classList.remove("flex");
                exitSelectionMode();
            }
            (
                document.getElementById("bulkRestoreBtn") as HTMLButtonElement
            )?.toggleAttribute("disabled", selection.size === 0);
            (
                document.getElementById("bulkPurgeBtn") as HTMLButtonElement
            )?.toggleAttribute("disabled", selection.size === 0);
            const selectAllBtn = document.getElementById(
                "selectAllBtn",
            ) as HTMLButtonElement | null;
            if (selectAllBtn) {
                const total = document.querySelectorAll(".tag-item").length;
                selectAllBtn.toggleAttribute(
                    "disabled",
                    selection.size === 0 ||
                        selection.size >= Math.min(total, MAX_BULK),
                );
            }
        }

        function enterSelectionMode() {
            if (selectionMode) return;
            selectionMode = true;
            document
                .querySelectorAll(".selection-checkbox")
                .forEach((el) =>
                    (el as HTMLInputElement).classList.remove("hidden"),
                );
            document
                .querySelectorAll(".color-indicator")
                .forEach((el) => el.classList.add("hidden"));
            document
                .querySelectorAll(".per-item-actions")
                .forEach((el) => (el as HTMLElement).classList.add("hidden"));
            document
                .getElementById("deletedTagsList")
                ?.classList.add("select-none");
        }

        function clearSelection() {
            selection.clear();
            document
                .querySelectorAll(".selection-checkbox")
                .forEach((el) => ((el as HTMLInputElement).checked = false));
            try {
                window.getSelection()?.removeAllRanges();
            } catch {}
            updateBulkBar();
        }

        function exitSelectionMode() {
            if (!selectionMode) return;
            selectionMode = false;
            document
                .querySelectorAll(".selection-checkbox")
                .forEach((el) => el.classList.add("hidden"));
            document
                .querySelectorAll(".color-indicator")
                .forEach((el) => el.classList.remove("hidden"));
            document
                .querySelectorAll(".per-item-actions")
                .forEach((el) =>
                    (el as HTMLElement).classList.remove("hidden"),
                );
            document
                .getElementById("deletedTagsList")
                ?.classList.remove("select-none");
            try {
                window.getSelection()?.removeAllRanges();
            } catch {}
        }

        window.addEventListener("keydown", (e) => {
            if (e.key === "Escape" && selectionMode) {
                clearSelection();
                exitSelectionMode();
            }
        });

        document.addEventListener("click", (e) => {
            const target = e.target as HTMLElement;
            const container = target.closest(".tag-item") as HTMLElement | null;
            if (!container) return;
            const id = parseInt(container.getAttribute("data-tag-id") || "0");
            const checkbox = container.querySelector(
                ".selection-checkbox",
            ) as HTMLInputElement | null;
            if (e.shiftKey && id && checkbox) {
                e.preventDefault();
                enterSelectionMode();
                if (selection.has(id)) {
                    selection.delete(id);
                    checkbox.checked = false;

                    // Direct checkbox click (without shift)
                    document.addEventListener("change", (e) => {
                        const target = e.target as HTMLElement;
                        if (target.classList.contains("selection-checkbox")) {
                            const cb = target as HTMLInputElement;
                            const id = parseInt(cb.value || "0");
                            if (!id) return;
                            if (!selectionMode) enterSelectionMode();
                            if (cb.checked) {
                                if (
                                    selection.size >= MAX_BULK &&
                                    !selection.has(id)
                                ) {
                                    cb.checked = false; // exceed limit
                                    return;
                                }
                                selection.add(id);
                            } else {
                                selection.delete(id);
                            }
                            updateBulkBar();
                        }
                    });
                } else if (selection.size < MAX_BULK) {
                    selection.add(id);
                    checkbox.checked = true;
                }
                updateBulkBar();
            }
        });

        document
            .getElementById("clearSelectionBtn")
            ?.addEventListener("click", () => {
                clearSelection();
            });
        document
            .getElementById("selectAllBtn")
            ?.addEventListener("click", () => {
                const items = Array.from(
                    document.querySelectorAll(".tag-item"),
                ) as HTMLElement[];
                let changed = false;
                for (const el of items) {
                    if (selection.size >= MAX_BULK) break;
                    const id = parseInt(el.getAttribute("data-tag-id") || "0");
                    if (id && !selection.has(id)) {
                        selection.add(id);
                        const cb = el.querySelector(
                            ".selection-checkbox",
                        ) as HTMLInputElement | null;
                        if (cb) cb.checked = true;
                        changed = true;
                    }
                }
                if (changed) updateBulkBar();
            });

        document
            .getElementById("bulkRestoreBtn")
            ?.addEventListener("click", async () => {
                if (selection.size === 0) return;
                const names: string[] = [];
                selection.forEach((id) => {
                    const el = document.querySelector(
                        `.tag-item[data-tag-id="${id}"]`,
                    );
                    if (el) {
                        const n = el.getAttribute("data-tag-name");
                        if (n) names.push(n);
                    }
                });
                const confirmationModal = document.getElementById(
                    "confirmationModal",
                ) as any;
                confirmationModal?.show({
                    title: "Restore Tags",
                    message: `Restore these tags?\n\n${names.join("\n")}`,
                    confirmLabel: "Restore",
                    cancelLabel: "Cancel",
                    onConfirm: async () => {
                        const csrfInput = document.querySelector(
                            'input[name="_csrf_token"]',
                        ) as HTMLInputElement;
                        const formData = new FormData();
                        formData.set("ids", Array.from(selection).join(","));
                        if (csrfInput?.value)
                            formData.set("_csrf_token", csrfInput.value);
                        const { ToastService } = await import("@lib/toast.ts");
                        try {
                            const { actions } = await import("astro:actions");
                            const result =
                                await actions.bulkRestoreTags(formData);
                            if (result.data?.ok) {
                                ToastService.success(
                                    `Restored ${result.data.restored} tags.`,
                                );
                                if (result.data.skipped?.length)
                                    ToastService.info(
                                        `${result.data.skipped.length} skipped.`,
                                    );
                                window.location.reload();
                            } else {
                                ToastService.error(
                                    result.data?.error || "Bulk restore failed",
                                );
                            }
                        } catch (err) {
                            console.error(err);
                        }
                    },
                });
            });

        document
            .getElementById("bulkPurgeBtn")
            ?.addEventListener("click", async () => {
                if (selection.size === 0) return;
                const names: string[] = [];
                selection.forEach((id) => {
                    const el = document.querySelector(
                        `.tag-item[data-tag-id="${id}"]`,
                    );
                    if (el) {
                        const n = el.getAttribute("data-tag-name");
                        if (n) names.push(n);
                    }
                });
                const confirmationModal = document.getElementById(
                    "confirmationModal",
                ) as any;
                confirmationModal?.show({
                    title: "Permanently Delete Tags",
                    message: `Permanently delete these tags? This cannot be undone.\n\n${names.join("\n")}`,
                    confirmLabel: "Purge",
                    cancelLabel: "Cancel",
                    onConfirm: async () => {
                        const csrfInput = document.querySelector(
                            'input[name="_csrf_token"]',
                        ) as HTMLInputElement;
                        const formData = new FormData();
                        formData.set("ids", Array.from(selection).join(","));
                        if (csrfInput?.value)
                            formData.set("_csrf_token", csrfInput.value);
                        const { ToastService } = await import("@lib/toast.ts");
                        try {
                            const { actions } = await import("astro:actions");
                            const result =
                                await actions.bulkPurgeTags(formData);
                            if (result.data?.ok) {
                                ToastService.success(
                                    `Purged ${result.data.purged} tags.`,
                                );
                                if (result.data.skipped?.length)
                                    ToastService.info(
                                        `${result.data.skipped.length} skipped.`,
                                    );
                                window.location.reload();
                            } else {
                                ToastService.error(
                                    result.data?.error || "Bulk purge failed",
                                );
                            }
                        } catch (err) {
                            console.error(err);
                        }
                    },
                });
            });

        // Handle restore tag forms
        document.addEventListener("DOMContentLoaded", function () {
            const restoreForms = document.querySelectorAll(".restore-tag-form");

            restoreForms.forEach((form) => {
                form.addEventListener("submit", async function (e) {
                    e.preventDefault();

                    const button = form.querySelector("button");
                    const tagName = button?.getAttribute("data-tag-name");

                    // Show confirmation modal
                    const confirmationModal = document.getElementById(
                        "confirmationModal",
                    ) as any;
                    if (!confirmationModal) {
                        console.error("Confirmation modal not found");
                        return;
                    }

                    confirmationModal.show({
                        title: "Restore Tag",
                        message: `Are you sure you want to restore "${tagName}"?`,
                        confirmLabel: "Restore",
                        cancelLabel: "Cancel",
                        onConfirm: async () => {
                            const csrfInput = document.querySelector(
                                'input[name="_csrf_token"]',
                            ) as HTMLInputElement;

                            const formData = new FormData(
                                form as HTMLFormElement,
                            );

                            if (csrfInput && csrfInput.value) {
                                formData.set("_csrf_token", csrfInput.value);
                            }

                            const { ToastService } = await import(
                                "@lib/toast.ts"
                            );

                            try {
                                const { actions } = await import(
                                    "astro:actions"
                                );
                                const result =
                                    await actions.restoreTag(formData);

                                if (result.data?.ok) {
                                    ToastService.success(
                                        "Tag restored successfully!",
                                    );
                                    // Reload the page to show updated data
                                    window.location.reload();
                                } else {
                                    ToastService.error(
                                        result.data?.error ||
                                            "Failed to restore tag",
                                    );
                                    console.error(
                                        "Tag restore failed:",
                                        result.error || result.data?.error,
                                    );
                                }
                            } catch (error) {
                                ToastService.error(
                                    "An error occurred. Please try again.",
                                );
                                console.error("Error restoring tag:", error);
                            }
                        },
                    });
                });
            });

            // Handle purge tag forms
            const purgeForms = document.querySelectorAll(".purge-tag-form");

            purgeForms.forEach((form) => {
                form.addEventListener("submit", async function (e) {
                    e.preventDefault();

                    const button = form.querySelector("button");
                    const tagName = button?.getAttribute("data-tag-name");

                    // Show confirmation modal
                    const confirmationModal = document.getElementById(
                        "confirmationModal",
                    ) as any;
                    if (!confirmationModal) {
                        console.error("Confirmation modal not found");
                        return;
                    }

                    confirmationModal.show({
                        title: "Permanently Delete Tag",
                        message: `Are you sure you want to permanently delete "${tagName}"? This action cannot be undone and will remove this tag from all transactions.`,
                        confirmLabel: "Purge",
                        cancelLabel: "Cancel",
                        onConfirm: async () => {
                            const csrfInput = document.querySelector(
                                'input[name="_csrf_token"]',
                            ) as HTMLInputElement;

                            const formData = new FormData(
                                form as HTMLFormElement,
                            );

                            if (csrfInput && csrfInput.value) {
                                formData.set("_csrf_token", csrfInput.value);
                            }

                            const { ToastService } = await import(
                                "@lib/toast.ts"
                            );

                            try {
                                const { actions } = await import(
                                    "astro:actions"
                                );
                                const result = await actions.purgeTag(formData);

                                if (result.data?.ok) {
                                    ToastService.success(
                                        "Tag permanently deleted!",
                                    );
                                    // Reload the page to show updated data
                                    window.location.reload();
                                } else {
                                    ToastService.error(
                                        result.data?.error ||
                                            "Failed to permanently delete tag",
                                    );
                                    console.error(
                                        "Tag purge failed:",
                                        result.error || result.data?.error,
                                    );
                                }
                            } catch (error) {
                                ToastService.error(
                                    "An error occurred. Please try again.",
                                );
                                console.error("Error purging tag:", error);
                            }
                        },
                    });
                });
            });
        });
    </script>
</Layout>
