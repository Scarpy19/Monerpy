---
import Layout from "@layouts/Layout.astro";
import Header from "@comps/layout/Header.astro";
import ConfirmationModal from "@comps/ConfirmationModal.astro";
import { actions } from "astro:actions";
import { formatDate, formatCurrency } from "@lib/date-utils.ts";
import Bin from "@comps/svgs/mono/Bin.astro";
import Loop from "@comps/svgs/mono/Loop.astro";
import DeletedInfo from "@comps/DeletedInfo.astro";

const user = Astro.locals.user;

if (!user) {
    return Astro.redirect("/login");
}

// Check if user is in a family first
const userResult = await Astro.callAction(actions.getFamilyDetails, {});
const userInFamily = userResult.data?.ok && userResult.data.family;

if (!userInFamily) {
    return Astro.redirect("/recurring");
}

// Get deleted recurring transactions
const recurringResult = await Astro.callAction(actions.getRecurringTransactions, {
    includeDeleted: true,
    page: 1,
    limit: 200
});
const rawRecurring = recurringResult.data?.ok ? recurringResult.data.recurringTransactions : [];

const deletedRecurring = Array.isArray(rawRecurring)
    ? rawRecurring.filter((r: any) => r.deletedAt !== null)
    : [];

// Calculate next execution dates for active recurring transactions (reuse logic from index)
const deletedWithNextDates = (deletedRecurring ?? []).map((rt) => {
    if (rt.status !== "active") {
        return { ...rt, nextExecution: null, upcomingDates: [] };
    }

    const now = new Date();
    const startDate = new Date(rt.startDate);
    let nextDate = new Date(Math.max(startDate.getTime(), now.getTime()));

    const upcomingDates: Date[] = [];
    let tempDate = new Date(nextDate);

    for (let i = 0; i < 5; i++) {
        const endDate = rt.endDate ? new Date(rt.endDate) : null;
        if (endDate && tempDate > endDate) break;
        if (rt.maxOccurrences && rt.occurrencesCount + i >= rt.maxOccurrences) break;

        switch (rt.frequency) {
            case "Daily":
                tempDate = new Date(tempDate);
                tempDate.setDate(tempDate.getDate() + (i === 0 ? 0 : 1));
                break;
            case "Weekly":
                if (i === 0) {
                    const currentDayOfWeek = tempDate.getDay();
                    const targetDayOfWeek = rt.dayOfWeek || 0;
                    const daysUntilNext = (targetDayOfWeek - currentDayOfWeek + 7) % 7;
                    tempDate.setDate(tempDate.getDate() + (daysUntilNext === 0 ? 7 : daysUntilNext));
                } else {
                    tempDate.setDate(tempDate.getDate() + 7);
                }
                break;
            case "Monthly":
                if (i === 0) {
                    tempDate.setDate(rt.dayOfMonth || 1);
                    if (tempDate <= now) {
                        tempDate.setMonth(tempDate.getMonth() + 1);
                    }
                } else {
                    tempDate.setMonth(tempDate.getMonth() + 1);
                }
                break;
            case "Yearly":
                if (i === 0) {
                    tempDate.setMonth(0);
                    tempDate.setDate(rt.dayOfMonth || 1);
                    if (tempDate <= now) {
                        tempDate.setFullYear(tempDate.getFullYear() + 1);
                    }
                } else {
                    tempDate.setFullYear(tempDate.getFullYear() + 1);
                }
                break;
        }

        upcomingDates.push(new Date(tempDate));
    }

    return {
        ...rt,
        nextExecution: upcomingDates[0] || null,
        upcomingDates,
    };
});

const deletedMsgs: string[] = [
    "Deleted recurring rules are hidden from the main schedule but their configuration is preserved",
    "Generated transactions remain intact when possible",
    "You can restore deleted recurring rules at any time",
    "Purging a recurring rule will permanently remove it and its logs"
];
---

<Layout title="Deleted Recurring Rules" description="Manage deleted recurring transactions">
    <main class="bg-gray-900 p-8 text-white">
        <Header currentPage="recurring" user={user} />
        <!-- Deleted Recurring List -->
        <div class="bg-gray-800 shadow-lg px-6 py-6 rounded-lg mx-auto max-w-7xl">
            <div class="flex items-center justify-between mb-6">
                <div class="flex items-baseline-last gap-x-4">
                    <h1 class="font-semibold text-purple-400 text-xl flex items-center gap-x-2">
                        <Bin />
                        Deleted Recurring Rules
                    </h1>
                    <a href="/recurring" class="text-purple-400 hover:text-purple-300 flex items-center gap-x-2">
                        <Loop class="w-4 h-4" />
                        <span>Recurring</span>
                    </a>
                </div>
                <div id="bulkHeaderBar" class="hidden items-center gap-x-4">
                    <div class="text-sm text-gray-300"><span id="selectedCount">0</span> selected (max 10)</div>
                    <div class="flex items-center gap-x-2">
                        <button id="bulkRestoreBtn" class="bg-green-600 hover:bg-green-700 text-white px-3 py-1 rounded text-sm disabled:opacity-40 disabled:cursor-not-allowed" disabled>Restore Selected</button>
                        <button id="bulkPurgeBtn" class="bg-red-600 hover:bg-red-700 text-white px-3 py-1 rounded text-sm disabled:opacity-40 disabled:cursor-not-allowed" disabled>Purge Selected</button>
                        <button id="clearSelectionBtn" class="bg-gray-600 hover:bg-gray-500 text-white px-3 py-1 rounded text-sm">Clear</button>
                        <button id="selectAllBtn" class="bg-purple-600 hover:bg-purple-500 text-white px-3 py-1 rounded text-sm disabled:opacity-40 disabled:cursor-not-allowed" disabled>Select All</button>
                    </div>
                </div>
            </div>

            {
                deletedRecurring.length === 0 ? (
                    <div class="text-center py-10 text-gray-400">
                        <div class="mb-4 flex justify-center"><Bin class="w-14 h-14" /></div>
                        <p class="text-xl font-semibold text-gray-300 mb-2">No deleted recurring rules</p>
                        <p>All your recurring rules are active!</p>
                    </div>
                ) : (
                    <div class="flex flex-col gap-y-4" id="deletedRecurringList">
                        {deletedWithNextDates.map((r: any) => (
                            <div class="bg-gray-700 rounded-lg p-6 hover:bg-gray-650 transition-all duration-200 hover:shadow-md border border-gray-600 hover:border-gray-500 recurring-item" data-recurring-id={r.id} data-recurring-name={r.description}>
                                <div class="grid grid-cols-1 lg:grid-cols-12 gap-6 items-start">
                                    <div class="lg:col-span-5">
                                        <div class="flex items-start justify-between mb-3">
                                            <div class="flex-1">
                                                <h3 class="font-semibold text-white text-lg leading-tight">{r.description}</h3>
                                                <div class="flex items-center gap-2 mt-1">
                                                    {r.account && (
                                                        <>
                                                            <span class="text-sm text-gray-400">{r.account.name}</span>
                                                            <div class="w-2 h-2 rounded-full" style={`background-color: ${r.account.color}`} />
                                                        </>
                                                    )}
                                                    <span class="text-xs text-gray-500">{r.frequency}</span>
                                                </div>
                                                <div class="flex items-center gap-3 mt-2 flex-wrap">
                                                    <div class="text-xs text-gray-400"><span class="font-medium text-gray-300">Start:</span> <span class="ml-1">{formatDate(r.startDate, { includeTime: false })}</span></div>
                                                    {r.endDate && (<div class="text-xs text-gray-400"><span class="font-medium text-gray-300">Ends:</span> <span class="ml-1">{formatDate(r.endDate, { includeTime: false })}</span></div>)}
                                                    {r.nextExecution && (<div class="text-xs text-yellow-400 font-medium">Next: {formatDate(r.nextExecution.toISOString().replace("T", " ").split(".")[0], { includeTime: false })}</div>)}
                                                </div>
                                            </div>
                                            <div class="text-sm text-gray-300">{r.type} • {formatCurrency(r.amount)}</div>
                                        </div>

                                        <div class="flex items-center gap-2 flex-wrap mb-3">
                                            {r.category && (
                                                <span class="px-2 py-1 rounded-full text-xs font-medium text-white" style={`background-color: ${r.category.color}`}>
                                                    {r.category.name}
                                                </span>
                                            )}
                                            {r.tags && r.tags.map((tag: any) => (
                                                <span class="text-xs px-2 py-1 rounded-full text-white border" style={`background-color: ${tag.color}; border-color: ${tag.color}`}>
                                                    {tag.name}
                                                </span>
                                            ))}
                                        </div>
                                    </div>

                                    <div class="lg:col-span-4">
                                        <div class="text-sm text-gray-300 flex flex-col gap-y-1">
                                            <div><span class="text-gray-400">Started:</span> {formatDate(r.startDate, { includeTime: false })}</div>
                                            {r.endDate && (<div><span class="text-gray-400">Ends:</span> {formatDate(r.endDate, { includeTime: false })}</div>)}
                                            {r.maxOccurrences && (<div><span class="text-gray-400">Occurrences:</span> {r.occurrencesCount} / {r.maxOccurrences} {r.remainingOccurrences !== null && (<span class="text-yellow-400 ml-1">({r.remainingOccurrences} left)</span>)}</div>)}
                                            <div><span class="text-gray-400">Time:</span> {r.timeOfDay}</div>
                                        </div>

                                        {r.nextExecution && (
                                            <div class="mt-3 p-2 bg-gray-600 rounded">
                                                <div class="text-xs text-gray-400">Next:</div>
                                                <div class="text-sm text-yellow-400 font-medium">{formatDate(r.nextExecution.toISOString().replace("T", " ").split(".")[0], { includeTime: false })}</div>
                                            </div>
                                        )}

                                        {r.upcomingDates && r.upcomingDates.length > 1 && (
                                            <div class="mt-2">
                                                <div class="text-xs text-gray-400 mb-1">Upcoming:</div>
                                                <div class="flex flex-wrap gap-1">
                                                    {r.upcomingDates.slice(1, 4).map((date: Date) => (
                                                        <span class="text-xs bg-gray-600 px-2 py-1 rounded text-gray-300">{date.toLocaleDateString("es-ES", { month: "short", day: "numeric" })}</span>
                                                    ))}
                                                </div>
                                            </div>
                                        )}
                                    </div>

                                    <div class="lg:col-span-3 flex lg:flex-col flex-row gap-2 lg:items-end">
                                        <form class="restore-recurring-form" method="post">
                                            <input type="hidden" name="id" value={r.id} />
                                            <button type="submit" class="bg-green-600 hover:bg-green-700 text-white px-3 py-2 rounded text-sm" data-recurring-name={r.description}>Restore</button>
                                        </form>
                                        <form class="purge-recurring-form" method="post">
                                            <input type="hidden" name="id" value={r.id} />
                                            <button type="submit" class="bg-red-600 hover:bg-red-700 text-white px-3 py-2 rounded text-sm" data-recurring-name={r.description}>Purge</button>
                                        </form>
                                    </div>

                                    {r.logs && r.logs.length > 0 && (
                                        <div class="lg:col-span-12 mt-4 pt-4 border-t border-gray-600">
                                            <div class="text-sm text-gray-400 mb-2">Recent Generated Transactions:</div>
                                            <div class="flex flex-wrap gap-2">
                                                {r.logs.slice(0, 3).map((log: any) => (
                                                    <div class="text-xs bg-gray-600 px-2 py-1 rounded">
                                                        {formatDate(log.executionTime, { includeTime: false })}
                                                        {log.generatedTransaction && (
                                                            <span class="text-green-400 ml-1">✓{formatCurrency(log.generatedTransaction.amount)}</span>
                                                        )}
                                                    </div>
                                                ))}
                                                {r.logs.length > 3 && (<div class="text-xs text-gray-400 px-2 py-1">+{r.logs.length - 3} more</div>)}
                                            </div>
                                        </div>
                                    )}
                                </div>
                            </div>
                        ))}
                    </div>
                )
            }
        </div>
        <DeletedInfo classes="mx-auto max-w-7xl" title="About Deleted Recurring Rules" listItems={deletedMsgs} />
    </main>

    <ConfirmationModal variant="info" />

    <script>
        // Multi-select state
        const selection = new Set<number>();
        let selectionMode = false;
        const MAX_BULK = 10;

        function updateBulkBar() {
            const bulkHeaderBar = document.getElementById("bulkHeaderBar");
            if (!bulkHeaderBar) return;
            const countEl = document.getElementById("selectedCount");
            if (countEl) countEl.textContent = String(selection.size);
            if (selection.size > 0) {
                bulkHeaderBar.classList.remove("hidden");
                bulkHeaderBar.classList.add("flex");
            } else {
                bulkHeaderBar.classList.add("hidden");
                bulkHeaderBar.classList.remove("flex");
                exitSelectionMode();
            }
            const bulkRestoreBtnEl = document.getElementById("bulkRestoreBtn");
            const bulkPurgeBtnEl = document.getElementById("bulkPurgeBtn");
            if (bulkRestoreBtnEl) bulkRestoreBtnEl.toggleAttribute("disabled", selection.size === 0);
            if (bulkPurgeBtnEl) bulkPurgeBtnEl.toggleAttribute("disabled", selection.size === 0);
            const selectAllBtn = document.getElementById("selectAllBtn");
            if (selectAllBtn) {
                const total = document.querySelectorAll(".recurring-item").length;
                const disableSelectAll = selection.size === 0 || selection.size >= Math.min(total, MAX_BULK);
                selectAllBtn.toggleAttribute("disabled", disableSelectAll);
            }
        }

        function enterSelectionMode() {
            if (selectionMode) return;
            selectionMode = true;
            document.querySelectorAll(".selection-checkbox").forEach((el) => el.classList.remove("hidden"));
            document.querySelectorAll(".per-item-actions").forEach((el) => (el).classList.add("hidden"));
            document.getElementById("deletedRecurringList")?.classList.add("select-none");
        }

        function clearSelection() {
            selection.clear();
            document.querySelectorAll(".selection-checkbox").forEach((el) => (el as HTMLInputElement).checked = false);
            try { window.getSelection()?.removeAllRanges(); } catch {}
            updateBulkBar();
        }

        function exitSelectionMode() {
            if (!selectionMode) return;
            selectionMode = false;
            document.querySelectorAll(".selection-checkbox").forEach((el) => el.classList.add("hidden"));
            document.querySelectorAll(".per-item-actions").forEach((el) => (el).classList.remove("hidden"));
            document.getElementById("deletedRecurringList")?.classList.remove("select-none");
            try { window.getSelection()?.removeAllRanges(); } catch {}
        }

        window.addEventListener("keydown", (e) => { if (e.key === "Escape" && selectionMode) { clearSelection(); exitSelectionMode(); } });

        document.addEventListener("click", (e) => {
            const target = e.target as HTMLElement;
            if (target.closest(".recurring-item")) {
                const container = target.closest(".recurring-item") as HTMLElement;
                const id = parseInt(container.getAttribute("data-recurring-id") || "0");
                const checkbox = container.querySelector(".selection-checkbox") as HTMLInputElement | null;
                if (e.shiftKey && id && checkbox) {
                    e.preventDefault();
                    enterSelectionMode();
                    if (selection.has(id)) { selection.delete(id); checkbox.checked = false; }
                    else { if (selection.size < MAX_BULK) { selection.add(id); checkbox.checked = true; } }
                    updateBulkBar();
                }
            }
        });

        document.addEventListener("change", (e) => {
            const target = e.target as HTMLElement;
            if (target.classList.contains("selection-checkbox")) {
                const cb = target as HTMLInputElement;
                const id = parseInt(cb.value || "0");
                if (!id) return;
                if (!selectionMode) enterSelectionMode();
                if (cb.checked) {
                    if (selection.size >= MAX_BULK && !selection.has(id)) { cb.checked = false; return; }
                    selection.add(id);
                } else {
                    selection.delete(id);
                }
                updateBulkBar();
            }
        });

        document.getElementById("clearSelectionBtn")?.addEventListener("click", () => clearSelection());

        document.getElementById("selectAllBtn")?.addEventListener("click", () => {
            const items = Array.from(document.querySelectorAll(".recurring-item")) as HTMLElement[];
            let changed = false;
            for (const el of items) {
                if (selection.size >= MAX_BULK) break;
                const id = parseInt(el.getAttribute("data-recurring-id") || "0");
                if (id && !selection.has(id)) {
                    selection.add(id);
                    const cb = el.querySelector('.selection-checkbox') as HTMLInputElement | null;
                    if (cb) cb.checked = true;
                    changed = true;
                }
            }
            if (changed) updateBulkBar();
        });

        document.getElementById("bulkRestoreBtn")?.addEventListener("click", async () => {
            if (selection.size === 0) return;
            const names: string[] = [];
            selection.forEach((id) => { const el = document.querySelector(`.recurring-item[data-recurring-id="${id}"]`); if (el) { const n = el.getAttribute('data-recurring-name'); if (n) names.push(n); } });
            const confirmationModal = document.getElementById("confirmationModal") as any;
            confirmationModal?.show({ title: 'Restore Recurring Rules', message: `Restore these recurring rules?\n\n${names.join('\n')}`, confirmLabel: 'Restore', cancelLabel: 'Cancel', onConfirm: async () => {
                const csrfInput = document.querySelector('input[name="_csrf_token"]') as HTMLInputElement;
                const formData = new FormData();
                formData.set('ids', Array.from(selection).join(','));
                if (csrfInput?.value) formData.set('_csrf_token', csrfInput.value);
                const { ToastService } = await import('@lib/toast.ts');
                try {
                    const { actions } = await import('astro:actions');
                    const result = await actions.bulkRestoreRecurring(formData);
                    if (result.data?.ok) {
                        ToastService.success(`Restored ${result.data.restored} recurring rules.`);
                        window.location.reload();
                    } else {
                        ToastService.showToast({ type: 'error', message: 'Bulk restore failed' });
                    }
                } catch (err) { console.error(err); }
            }});
        });

        document.getElementById("bulkPurgeBtn")?.addEventListener("click", async () => {
            if (selection.size === 0) return;
            const names: string[] = [];
            selection.forEach((id) => { const el = document.querySelector(`.recurring-item[data-recurring-id="${id}"]`); if (el) { const n = el.getAttribute('data-recurring-name'); if (n) names.push(n); } });
            const confirmationModal = document.getElementById("confirmationModal") as any;
            confirmationModal?.show({ title: 'Permanently Delete Recurring Rules', message: `Permanently delete these recurring rules? This cannot be undone.\n\n${names.join('\n')}`, confirmLabel: 'Purge', cancelLabel: 'Cancel', onConfirm: async () => {
                const csrfInput = document.querySelector('input[name="_csrf_token"]') as HTMLInputElement;
                const formData = new FormData();
                formData.set('ids', Array.from(selection).join(','));
                if (csrfInput?.value) formData.set('_csrf_token', csrfInput.value);
                const { ToastService } = await import('@lib/toast.ts');
                try {
                    const { actions } = await import('astro:actions');
                    const result = await actions.bulkPurgeRecurring(formData);
                    if (result.data?.ok) {
                        ToastService.success(`Purged ${result.data.purged} recurring rules.`);
                        window.location.reload();
                    } else {
                        ToastService.showToast({ type: 'error', message: 'Bulk purge failed' });
                    }
                } catch (err) { console.error(err); }
            }});
        });

        document.addEventListener('DOMContentLoaded', function() {
            const restoreForms = document.querySelectorAll('.restore-recurring-form');
            restoreForms.forEach((form) => {
                form.addEventListener('submit', function(e) {
                    e.preventDefault();
                    const button = form.querySelector('button');
                    const name = button?.getAttribute('data-recurring-name');
                    const confirmationModal = document.getElementById('confirmationModal') as any;
                    if (!confirmationModal) return console.error('Confirmation modal not found');
                    confirmationModal.show({ title: 'Restore Recurring Rule', message: `Are you sure you want to restore "${name}"?`, confirmLabel: 'Restore', cancelLabel: 'Cancel', onConfirm: async () => {
                        const csrfInput = document.querySelector('input[name="_csrf_token"]') as HTMLInputElement;
                        const formData = new FormData(form as HTMLFormElement);
                        if (csrfInput && csrfInput.value) formData.set('_csrf_token', csrfInput.value);
                        const { ToastService } = await import('@lib/toast.ts');
                        try {
                            const { actions } = await import('astro:actions');
                            const result = await actions.restoreRecurringTransaction(formData);
                            if (result.data?.ok) { ToastService.success('Restored recurring rule.'); window.location.reload(); }
                            else { ToastService.showToast({ type: 'error', message: 'Restore failed' }); console.error(result); }
                        } catch (err) { const msg = err instanceof Error ? err.message : String(err); ToastService.showToast({ type: 'error', message: `An error occurred. ${msg}` }); console.error(err); }
                    }});
                });
            });

            const purgeForms = document.querySelectorAll('.purge-recurring-form');
            purgeForms.forEach((form) => {
                form.addEventListener('submit', function(e) {
                    e.preventDefault();
                    const button = form.querySelector('button');
                    const name = button?.getAttribute('data-recurring-name');
                    const confirmationModal = document.getElementById('confirmationModal') as any;
                    if (!confirmationModal) return console.error('Confirmation modal not found');
                    confirmationModal.show({ title: 'Permanently Delete Recurring Rule', message: `Are you sure you want to permanently delete "${name}"? This cannot be undone.`, confirmLabel: 'Purge', cancelLabel: 'Cancel', onConfirm: async () => {
                        const csrfInput = document.querySelector('input[name="_csrf_token"]') as HTMLInputElement;
                        const formData = new FormData(form as HTMLFormElement);
                        if (csrfInput && csrfInput.value) formData.set('_csrf_token', csrfInput.value);
                        const { ToastService } = await import('@lib/toast.ts');
                        try {
                            const { actions } = await import('astro:actions');
                            const result = await actions.purgeRecurringTransaction(formData);
                            if (result.data?.ok) { ToastService.success('Purged recurring rule.'); window.location.reload(); }
                            else { ToastService.showToast({ type: 'error', message: 'Purge failed' }); console.error(result); }
                        } catch (err) { const msg = err instanceof Error ? err.message : String(err); ToastService.showToast({ type: 'error', message: `An error occurred. ${msg}` }); console.error(err); }
                    }});
                });
            });
        });
    </script>
</Layout>
