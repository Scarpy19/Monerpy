---
import X from "@svg/mono/X.astro";
import Input from "@comps/Input.astro";
import TypePicker from "@comps/TypePicker.astro";
import Amount from "@comps/transaction/Amount.astro";
import Account from "@comps/transaction/Account.astro";
import Date from "@comps/transaction/Date.astro";
import Category from "@comps/transaction/Category.astro";
import TagsDropdownSelect from "@comps/tags/TagsDropdownSelect.astro";
import ScriptSelect from "@comps/accounts/ScriptSelect.astro";

interface Props {
    id: string;
}

const { id } = Astro.props as Props;
---

<transaction-modal id={id}>
    <div
        class="modal-root fixed inset-0 bg-black/50 hidden items-center justify-center z-50"
    >
        <div
            class="bg-gray-800 rounded-lg w-full max-w-2xl max-h-[90vh] overflow-y-auto"
        >
            <header
                class="flex items-end justify-between py-4.5 px-6 border-b border-gray-700"
            >
                <h2
                    class="font-semibold text-purple-400 text-xl"
                    id="modalTitle"
                >
                    Add Transaction
                </h2>
                <button
                    type="button"
                    id="closeModalButton"
                    class="text-gray-400 hover:text-white"
                >
                    <X class="w-6 h-6" />
                </button>
            </header>

            <form
                id="transactionForm"
                class="p-6 flex flex-col gap-y-4"
                novalidate
            >
                <!-- Account and Name -->
                <div class="flex items-center gap-x-4 justify-center">
                    <Account id="accountId" classes="flex-1" />

                    <Input
                        id="name"
                        label="Transaction Name"
                        name="name"
                        required={true}
                        placeholder="Enter transaction name"
                        classes="flex-1/3"
                    />

                    <ScriptSelect idSelect="accountId" />
                </div>

                <!-- Transaction Type and Amount -->
                <div class="flex items-center gap-x-4 justify-center">
                    <TypePicker classes="flex-1" />
                    <Amount classes="flex-1/3" />
                </div>

                <div class="flex items-center gap-x-4 justify-center">
                    <Category classes="flex-1" />
                    <Date id="date" name="date" label="Date" />
                </div>

                <!-- Tags -->
                <TagsDropdownSelect id="tags" name="tags" label="Tags" />

                <!-- Form Buttons -->
                <div class="flex gap-3 pt-4">
                    <div class="flex-3 text-right">
                        <button
                            type="button"
                            id="cancelBtn"
                            class="bg-gray-600 hover:bg-gray-700 px-4 py-2 rounded text-white transition duration-200"
                        >
                            Cancel
                        </button>
                    </div>
                    <button
                        type="submit"
                        id="submitBtn"
                        class="flex-2 bg-purple-600 hover:bg-purple-700 px-4 py-2 rounded text-white transition duration-200 disabled:opacity-70 disabled:cursor-not-allowed flex items-center justify-center gap-2"
                    >
                        <span id="submitBtnText">Add Transaction</span>
                        <span
                            id="submitSpinner"
                            class="hidden w-4 h-4 border-2 border-white/60 border-t-transparent rounded-full animate-spin"
                        ></span>
                    </button>
                </div>
            </form>
        </div>
    </div>

    <script>
        // Import date utility functions once
        import { getCurrentDateTimeLocal } from "@lib/date-utils.ts";

        class TransactionModal extends HTMLElement {
            connectedCallback() {
                // root overlay inside the custom element
                const modal = this.querySelector(
                    ".modal-root",
                ) as HTMLDivElement;
                const closeModalButton = this.querySelector(
                    "#closeModalButton",
                ) as HTMLButtonElement;
                const cancelBtn = this.querySelector(
                    "#cancelBtn",
                ) as HTMLButtonElement;

                const dateInput = this.querySelector(
                    "#date",
                ) as HTMLInputElement;
                const formTitle = this.querySelector(
                    "#modalTitle",
                ) as HTMLHeadingElement;
                const submitText = this.querySelector(
                    "#submitBtnText",
                ) as HTMLSpanElement;
                const submitBtn = this.querySelector(
                    "#submitBtn",
                ) as HTMLButtonElement;
                const submitSpinner = this.querySelector(
                    "#submitSpinner",
                ) as HTMLSpanElement;
                const form = this.querySelector(
                    "#transactionForm",
                ) as HTMLFormElement;
                // Focus trap tracking
                let focusable: HTMLElement[] = [];
                let firstFocusable: HTMLElement | null = null;
                let lastFocusable: HTMLElement | null = null;

                const accountId = this.querySelector(
                    "#accountId",
                ) as HTMLSelectElement;
                // radios inside TypePicker handle type
                const name = this.querySelector("#name") as HTMLInputElement;
                const tags = this.querySelector("#tags") as HTMLInputElement;
                const tagsDropdownRoots = this.querySelectorAll(
                    "[data-tags-dropdown-root]",
                ) as NodeListOf<HTMLDivElement>;

                const computeFocusables = () => {
                    const dialogPanel = this.querySelector(
                        '[role="dialog"]',
                    ) as HTMLElement;
                    if (!dialogPanel) return;
                    focusable = Array.from(
                        dialogPanel.querySelectorAll<HTMLElement>(
                            'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])',
                        ),
                    ).filter(
                        (el) =>
                            !el.hasAttribute("disabled") &&
                            !el.getAttribute("aria-hidden"),
                    );
                    firstFocusable = focusable[0] || null;
                    lastFocusable = focusable[focusable.length - 1] || null;
                };

                const openModal = (opts?: any) => {
                    // opts: { type?: string, accountId?: string }
                    try {
                        const savedAccount =
                            opts && opts.accountId
                                ? opts.accountId
                                : window.localStorage
                                  ? window.localStorage.getItem(
                                        "selectedAccountId",
                                    )
                                  : null;
                        if (savedAccount && accountId)
                            accountId.value = savedAccount;
                    } catch (e) {
                        // ignore localStorage errors
                    }

                    // set type if provided
                    if (opts && opts.type) {
                        const radios = Array.from(
                            this.querySelectorAll('input[name="type"]'),
                        );
                        const matching = radios.find(
                            (r) => r.getAttribute("value") === opts.type,
                        );
                        if (matching && matching instanceof HTMLInputElement) {
                            matching.checked = true;
                            matching.dispatchEvent(new Event("change"));
                        }
                    }

                    if (modal) {
                        modal.classList.remove("hidden");
                        modal.classList.add("flex");
                        document.body.style.overflow = "hidden";
                        computeFocusables();
                        // focus name input
                        if (name && typeof name.focus === "function")
                            name.focus();
                    }
                };

                const closeModal = () => {
                    if (modal) {
                        modal.classList.add("hidden");
                        modal.classList.remove("flex");
                        document.body.style.overflow = "auto";
                        resetForm();
                    }
                };

                const resetForm = async () => {
                    if (formTitle) formTitle.textContent = "Add Transaction";
                    if (submitText) submitText.textContent = "Add Transaction";
                    if (form) form.reset();
                    if (dateInput) {
                        dateInput.value = getCurrentDateTimeLocal();
                    }
                    // restore saved account after reset
                    try {
                        const saved =
                            window.localStorage.getItem("selectedAccountId");
                        if (saved && accountId) accountId.value = saved;
                    } catch (e) {}

                    // reset tags input value
                    if (tags) tags.value = "";
                    // invoke component-level reset if exposed
                    if (tagsDropdownRoots && tagsDropdownRoots.length > 0) {
                        tagsDropdownRoots.forEach((root) => {
                            const anyRoot: any = root;
                            if (typeof anyRoot.resetTags === "function") {
                                try {
                                    anyRoot.resetTags();
                                } catch (_) {}
                            }
                        });
                    }
                };

                // Hook up events
                if (closeModalButton)
                    closeModalButton.addEventListener("click", closeModal);
                if (cancelBtn) cancelBtn.addEventListener("click", closeModal);

                // Handle form submission
                if (form) {
                    form.addEventListener("submit", async (e) => {
                        e.preventDefault();

                        const formData = new FormData(form);
                        const csrfInput = document.querySelector(
                            'input[name="_csrf_token"]',
                        ) as HTMLInputElement;

                        if (csrfInput && csrfInput.value) {
                            formData.set("_csrf_token", csrfInput.value);
                        }
                        // Submit create only
                        if (submitBtn) {
                            submitBtn.disabled = true;
                            submitSpinner?.classList.remove("hidden");
                        }

                        try {
                            const { actions } = await import("astro:actions");
                            const result =
                                await actions.createTransaction(formData);

                            if (result?.data?.ok) {
                                const { ToastService } = await import(
                                    "@lib/toast.ts"
                                );
                                ToastService.success(
                                    "Transaction created successfully!",
                                );
                                closeModal();
                                // Reload the page to show updated data
                                window.location.reload();
                            } else {
                                const { ToastService } = await import(
                                    "@lib/toast.ts"
                                );
                                ToastService.showToast({
                                    message:
                                        "Failed to create transaction. Please try again.",
                                    type: "error",
                                });
                                console.error(
                                    "Transaction operation failed:",
                                    result?.error || result?.data?.error,
                                );
                            }
                        } catch (error) {
                            const { ToastService } = await import(
                                "@lib/toast.ts"
                            );
                            ToastService.error(
                                "An error occurred. Please try again.",
                            );
                            console.error(
                                "Error submitting transaction:",
                                error,
                            );
                        } finally {
                            if (submitBtn) {
                                submitBtn.disabled = false;
                                submitSpinner?.classList.add("hidden");
                            }
                        }
                    });
                }

                if (modal) {
                    let downOutside = false;
                    modal.addEventListener("mousedown", (e) => {
                        if (
                            e.target === modal &&
                            (e as MouseEvent).button === 0
                        ) {
                            downOutside = true;
                        } else {
                            downOutside = false;
                        }
                    });
                    modal.addEventListener("mouseup", (e) => {
                        if (
                            downOutside &&
                            e.target === modal &&
                            (e as MouseEvent).button === 0
                        ) {
                            closeModal();
                        }
                        downOutside = false;
                    });
                }

                // default date
                if (dateInput) dateInput.value = getCurrentDateTimeLocal();

                // expose instance methods
                (this as any).openModal = openModal;
                (this as any).closeModal = closeModal;
                (this as any).resetForm = resetForm;
                // Persist account selection when user changes it
                if (accountId) {
                    accountId.addEventListener("change", () => {
                        try {
                            window.localStorage.setItem(
                                "selectedAccountId",
                                accountId.value,
                            );
                        } catch (e) {}
                    });
                }

                // Focus trap & ESC handling at root
                this.addEventListener("keydown", (e: KeyboardEvent) => {
                    if (e.key === "Escape") {
                        e.stopPropagation();
                        closeModal();
                        return;
                    }
                    if (e.key === "Tab") {
                        computeFocusables();
                        if (!firstFocusable || !lastFocusable) return;
                        if (e.shiftKey) {
                            if (document.activeElement === firstFocusable) {
                                e.preventDefault();
                                lastFocusable.focus();
                            }
                        } else {
                            if (document.activeElement === lastFocusable) {
                                e.preventDefault();
                                firstFocusable.focus();
                            }
                        }
                    }
                });
            }
        }

        // Register the custom element
        if (!customElements.get("transaction-modal")) {
            customElements.define("transaction-modal", TransactionModal);
        }

        // No global helpers: prefer instance methods on <transaction-modal id="..."> elements
    </script>
</transaction-modal>
